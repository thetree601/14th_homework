# 답변하기 기능 구현 가이드

## 개요
/secrets 상세페이지의 문의하기 기능에 답변하기 기능을 추가합니다. 각 문의(Question)에 대해 답변을 작성, 수정, 삭제할 수 있는 기능을 제공합니다. GraphQL API를 사용하여 UseditemQuestionAnswer 데이터를 관리합니다.

## 핵심 요구사항

### 1. 데이터 구조

#### 1.1 GraphQL 스키마
- **createUseditemQuestionAnswer**: 답변 작성
  - Input: `CreateUseditemQuestionAnswerInput` (contents: String!)
  - Parameter: `useditemQuestionId: ID!`
  - Return: `UseditemQuestionAnswer!`

- **updateUseditemQuestionAnswer**: 답변 수정
  - Input: `UpdateUseditemQuestionAnswerInput` (contents: String!)
  - Parameter: `useditemQuestionAnswerId: ID!`
  - Return: `UseditemQuestionAnswer!`

- **deleteUseditemQuestionAnswer**: 답변 삭제
  - Parameter: `useditemQuestionAnswerId: ID!`
  - Return: `String!`

- **UseditemQuestionAnswer 타입**:
  - `_id: ID!` - 답변 고유 식별자
  - `contents: String!` - 답변 내용
  - `useditemQuestion: UseditemQuestion!` - 해당 문의
  - `user: User!` - 작성자 정보
  - `createdAt: DateTime!` - 생성 시간
  - `updatedAt: DateTime!` - 수정 시간
  - `deletedAt: DateTime` - 삭제 시간 (nullable)

#### 1.2 TypeScript 인터페이스
```typescript
export interface Answer {
  _id: string;
  contents: string;
  useditemQuestion: {
    _id: string;
  };
  user: {
    _id: string;
    name: string;
    email?: string;
  };
  createdAt: string;
  updatedAt: string;
  deletedAt?: string | null;
}

export interface QuestionWithAnswers extends Question {
  answers?: Answer[];
}
```

### 2. 기능 요구사항

#### 2.1 답변 작성
- 각 문의 항목 아래에 "답변하기" 버튼 또는 링크 표시
- 답변하기 클릭 시 해당 문의에 대한 답변 작성 폼 표시
- 답변 내용 입력 (textarea 사용)
- 등록 버튼 클릭 시 GraphQL mutation 실행
- 등록 성공 시 해당 문의의 답변 목록에 즉시 반영
- 등록 실패 시 에러 메시지 표시

#### 2.2 답변 조회
- 각 문의 항목 아래에 해당 문의에 대한 답변 목록 표시
- 답변이 없는 경우 "아직 답변이 없습니다." 메시지 표시
- 답변이 있는 경우 답변 목록을 최신순 또는 생성순으로 정렬하여 표시
- 각 답변 항목에는 답변 내용, 작성자, 작성 시간 표시

#### 2.3 답변 수정
- 각 답변 항목에 수정 아이콘 표시 (기존 문의하기에서 사용하던 `/images/edit.png` 재사용)
- 수정 아이콘 클릭 시 해당 답변 내용을 편집 가능한 상태로 전환
- 수정 모드에서는 textarea와 저장/취소 버튼 표시
- 저장 시 GraphQL mutation 실행하여 답변 내용 업데이트
- 취소 시 수정 모드 해제 및 원래 내용으로 복원
- 수정 후 즉시 목록에 반영

#### 2.4 답변 삭제
- 각 답변 항목에 삭제 아이콘 표시 (기존 문의하기에서 사용하던 `/images/delete2.png` 재사용)
- 삭제 아이콘 클릭 시 삭제 확인 다이얼로그 표시
- 확인 시 GraphQL mutation 실행하여 답변 삭제
- 삭제 후 즉시 목록에서 제거

### 3. UI/UX 요구사항

#### 3.1 답변 목록 표시
- 각 문의 항목 아래에 들여쓰기된 형태로 답변 목록 표시
- 답변 항목은 문의 항목과 시각적으로 구분되도록 스타일링
- 답변 항목 배경색은 문의 항목보다 약간 더 어둡거나 다른 색상으로 구분
- 답변 항목 간 적절한 간격 유지 (8px ~ 12px)

#### 3.2 답변 작성 폼
- 각 문의 항목 아래에 "답변하기" 버튼 표시
- 버튼 클릭 시 해당 문의에 대한 답변 작성 폼 표시
- 폼은 QuestionForm과 유사한 스타일 적용
- textarea 사용 (rows: 3 ~ 4)
- 등록 버튼 및 취소 버튼 제공
- 폼 제출 시 유효성 검사 (빈 값 체크 등)
- 답변 작성 중인 문의는 다른 답변 작성 폼 숨김 처리

#### 3.3 아이콘 배치
- 각 답변 항목의 우측 하단에 수정/삭제 아이콘 배치
- 아이콘은 hover 시 시각적 피드백 제공
- 아이콘 크기: 16px (기존 문의하기와 동일)
- 아이콘 간 간격: 8px (기존 문의하기와 동일)
- Next.js Image 컴포넌트 사용

#### 3.4 아이콘 파일 경로
- 수정 아이콘: `/images/edit.png`
- 삭제 아이콘: `/images/delete2.png`

#### 3.5 수정 모드 UI
- 수정 모드 진입 시 해당 답변 항목의 contents가 편집 가능한 textarea로 전환
- textarea는 기존 QuestionForm의 textarea와 유사한 스타일
- 저장 버튼과 취소 버튼 표시
- 수정 모드에서는 다른 답변 항목의 수정/삭제 아이콘 비활성화 또는 숨김 처리

#### 3.6 삭제 확인
- 삭제 아이콘 클릭 시 확인 다이얼로그 표시
- "정말 삭제하시겠습니까?" 메시지와 함께 확인/취소 버튼 제공
- window.confirm 사용 또는 기존 DeleteConfirmModal 컴포넌트 활용

### 4. 기술 요구사항

#### 4.1 GraphQL Mutations
- `mutations.ts` 또는 별도 파일에 GraphQL mutation 정의
- Apollo Client의 `useMutation` 훅 사용
- mutation 실행 후 캐시 업데이트 또는 refetch 처리

#### 4.2 GraphQL Queries
- 문의 조회 시 해당 문의의 답변 목록도 함께 조회
- `useditemQuestion.answers` 필드를 포함하여 조회
- 답변이 없는 경우 빈 배열 처리

#### 4.3 컴포넌트 구조
- `QuestionsList.tsx` 확장하여 답변 목록 표시 기능 추가
- `AnswerForm.tsx` 새로 생성 (답변 작성 폼 컴포넌트)
- `AnswerItem.tsx` 새로 생성 (개별 답변 항목 컴포넌트, 선택사항)
- `SecretComments.tsx`에서 답변 관련 핸들러 구현 및 전달

#### 4.4 상태 관리
- 각 문의에 대한 답변 작성 폼 표시 상태 관리
- 각 답변의 수정 모드 상태 관리
- 로딩 상태 및 에러 상태 관리

### 5. 구현 파일

#### 5.1 수정할 파일
- `components/secrets-detail/mutations.ts` - GraphQL mutations 추가 (답변 작성/수정/삭제)
- `components/secrets-detail/queries.ts` - GraphQL queries 수정 (답변 목록 포함)
- `components/secrets-detail/QuestionsList.tsx` - 답변 목록 표시 기능 추가
- `components/secrets-detail/QuestionsList.module.css` - 답변 관련 스타일 추가
- `components/secrets-detail/SecretComments.tsx` - 답변 관련 핸들러 추가 및 전달

#### 5.2 새로 생성할 파일
- `components/secrets-detail/AnswerForm.tsx` - 답변 작성 폼 컴포넌트
- `components/secrets-detail/AnswerForm.module.css` - 답변 작성 폼 스타일
- `components/secrets-detail/AnswerItem.tsx` - 개별 답변 항목 컴포넌트 (선택사항)
- `components/secrets-detail/AnswerItem.module.css` - 답변 항목 스타일 (선택사항)

### 6. GraphQL Mutation 예시 코드

#### 6.1 답변 작성 Mutation
```typescript
import { gql } from "@apollo/client";

export const CREATE_USEDITEM_QUESTION_ANSWER = gql`
  mutation createUseditemQuestionAnswer(
    $createUseditemQuestionAnswerInput: CreateUseditemQuestionAnswerInput!
    $useditemQuestionId: ID!
  ) {
    createUseditemQuestionAnswer(
      createUseditemQuestionAnswerInput: $createUseditemQuestionAnswerInput
      useditemQuestionId: $useditemQuestionId
    ) {
      _id
      contents
      createdAt
      updatedAt
      user {
        _id
        name
        email
      }
      useditemQuestion {
        _id
      }
    }
  }
`;
```

#### 6.2 답변 수정 Mutation
```typescript
export const UPDATE_USEDITEM_QUESTION_ANSWER = gql`
  mutation updateUseditemQuestionAnswer(
    $updateUseditemQuestionAnswerInput: UpdateUseditemQuestionAnswerInput!
    $useditemQuestionAnswerId: ID!
  ) {
    updateUseditemQuestionAnswer(
      updateUseditemQuestionAnswerInput: $updateUseditemQuestionAnswerInput
      useditemQuestionAnswerId: $useditemQuestionAnswerId
    ) {
      _id
      contents
      updatedAt
    }
  }
`;
```

#### 6.3 답변 삭제 Mutation
```typescript
export const DELETE_USEDITEM_QUESTION_ANSWER = gql`
  mutation deleteUseditemQuestionAnswer($useditemQuestionAnswerId: ID!) {
    deleteUseditemQuestionAnswer(useditemQuestionAnswerId: $useditemQuestionAnswerId)
  }
`;
```

### 7. 구현 예시 코드 구조

#### 7.1 AnswerForm.tsx - 답변 작성 폼
```typescript
"use client";

import React, { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import styles from "./AnswerForm.module.css";

const answerSchema = z.object({
  contents: z.string().min(1, "답변 내용을 입력해주세요."),
});

type AnswerFormData = z.infer<typeof answerSchema>;

interface AnswerFormProps {
  questionId: string;
  onSubmit: (questionId: string, contents: string) => Promise<void>;
  onCancel: () => void;
}

export default function AnswerForm({ questionId, onSubmit, onCancel }: AnswerFormProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<AnswerFormData>({
    resolver: zodResolver(answerSchema),
  });

  const handleFormSubmit = async (data: AnswerFormData) => {
    setIsSubmitting(true);
    try {
      await onSubmit(questionId, data.contents);
      reset();
    } catch (error) {
      console.error("답변 등록 중 오류:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form className={styles.form} onSubmit={handleSubmit(handleFormSubmit)}>
      <textarea
        {...register("contents")}
        className={styles.textarea}
        placeholder="답변 내용을 입력해주세요..."
        rows={3}
      />
      {errors.contents && (
        <p className={styles.error}>{errors.contents.message}</p>
      )}
      <div className={styles.actions}>
        <button type="button" className={styles.cancelBtn} onClick={onCancel}>
          취소
        </button>
        <button
          type="submit"
          className={styles.submitBtn}
          disabled={isSubmitting}
        >
          {isSubmitting ? "등록 중..." : "등록"}
        </button>
      </div>
    </form>
  );
}
```

#### 7.2 QuestionsList.tsx - 답변 목록 표시 추가
```typescript
"use client";

import React, { useState } from "react";
import Image from "next/image";
import styles from "./QuestionsList.module.css";
import { Question } from "./mutations";
import AnswerForm from "./AnswerForm";
import { Answer } from "./types";

interface QuestionsListProps {
  questions: Question[];
  answers?: Record<string, Answer[]>; // questionId를 키로 하는 답변 목록
  onEdit?: (questionId: string, newContent: string) => Promise<void>;
  onDelete?: (questionId: string) => Promise<void>;
  onAnswerSubmit?: (questionId: string, contents: string) => Promise<void>;
  onAnswerEdit?: (answerId: string, newContents: string) => Promise<void>;
  onAnswerDelete?: (answerId: string) => Promise<void>;
}

export default function QuestionsList({ 
  questions, 
  answers = {},
  onEdit, 
  onDelete,
  onAnswerSubmit,
  onAnswerEdit,
  onAnswerDelete,
}: QuestionsListProps) {
  const [showAnswerForm, setShowAnswerForm] = useState<string | null>(null);
  const [editingAnswerId, setEditingAnswerId] = useState<string | null>(null);
  const [editAnswerContent, setEditAnswerContent] = useState<string>("");

  const handleAnswerFormCancel = () => {
    setShowAnswerForm(null);
  };

  const handleAnswerSubmit = async (questionId: string, contents: string) => {
    if (!onAnswerSubmit) return;
    await onAnswerSubmit(questionId, contents);
    setShowAnswerForm(null);
  };

  const handleAnswerEditClick = (answer: Answer) => {
    setEditingAnswerId(answer._id);
    setEditAnswerContent(answer.contents);
  };

  const handleAnswerEditCancel = () => {
    setEditingAnswerId(null);
    setEditAnswerContent("");
  };

  const handleAnswerEditSave = async (answerId: string) => {
    if (!onAnswerEdit) return;
    await onAnswerEdit(answerId, editAnswerContent);
    setEditingAnswerId(null);
    setEditAnswerContent("");
  };

  const handleAnswerDeleteClick = async (answerId: string) => {
    if (!onAnswerDelete) return;
    const confirmed = window.confirm("정말 삭제하시겠습니까?");
    if (confirmed) {
      await onAnswerDelete(answerId);
    }
  };

  return (
    <div className={styles.list}>
      {questions.map((question) => {
        const questionAnswers = answers[question.id] || [];
        return (
          <div key={question.id} className={styles.item}>
            {/* 문의 내용 (기존 코드) */}
            <div className={styles.content}>{question.content}</div>
            <div className={styles.footer}>
              <div className={styles.time}>{formatRelativeTime(question.createdAt)}</div>
              <div className={styles.actions}>
                {/* 수정/삭제 아이콘 (기존 코드) */}
              </div>
            </div>

            {/* 답변 목록 */}
            {questionAnswers.length > 0 && (
              <div className={styles.answers}>
                {questionAnswers.map((answer) => (
                  <div key={answer._id} className={styles.answerItem}>
                    {editingAnswerId === answer._id ? (
                      // 수정 모드
                      <div className={styles.editMode}>
                        <textarea
                          className={styles.editTextarea}
                          value={editAnswerContent}
                          onChange={(e) => setEditAnswerContent(e.target.value)}
                          rows={3}
                        />
                        <div className={styles.editActions}>
                          <button
                            type="button"
                            className={styles.cancelBtn}
                            onClick={handleAnswerEditCancel}
                          >
                            취소
                          </button>
                          <button
                            type="button"
                            className={styles.saveBtn}
                            onClick={() => handleAnswerEditSave(answer._id)}
                          >
                            저장
                          </button>
                        </div>
                      </div>
                    ) : (
                      // 일반 모드
                      <>
                        <div className={styles.answerContent}>{answer.contents}</div>
                        <div className={styles.answerFooter}>
                          <div className={styles.answerInfo}>
                            <span className={styles.answerAuthor}>{answer.user.name}</span>
                            <span className={styles.answerTime}>
                              {formatRelativeTime(answer.createdAt)}
                            </span>
                          </div>
                          <div className={styles.answerActions}>
                            {onAnswerEdit && (
                              <button
                                type="button"
                                className={styles.actionBtn}
                                onClick={() => handleAnswerEditClick(answer)}
                                aria-label="수정"
                              >
                                <Image
                                  src="/images/edit.png"
                                  alt="수정"
                                  width={16}
                                  height={16}
                                />
                              </button>
                            )}
                            {onAnswerDelete && (
                              <button
                                type="button"
                                className={styles.actionBtn}
                                onClick={() => handleAnswerDeleteClick(answer._id)}
                                aria-label="삭제"
                              >
                                <Image
                                  src="/images/delete2.png"
                                  alt="삭제"
                                  width={16}
                                  height={16}
                                />
                              </button>
                            )}
                          </div>
                        </div>
                      </>
                    )}
                  </div>
                ))}
              </div>
            )}

            {/* 답변 작성 폼 또는 답변하기 버튼 */}
            {showAnswerForm === question.id ? (
              <AnswerForm
                questionId={question.id}
                onSubmit={handleAnswerSubmit}
                onCancel={handleAnswerFormCancel}
              />
            ) : (
              onAnswerSubmit && (
                <button
                  type="button"
                  className={styles.answerBtn}
                  onClick={() => setShowAnswerForm(question.id)}
                >
                  답변하기
                </button>
              )
            )}
          </div>
        );
      })}
    </div>
  );
}
```

#### 7.3 SecretComments.tsx - 답변 핸들러 추가
```typescript
"use client";

import React, { useState, useEffect } from "react";
import { useMutation } from "@apollo/client";
import styles from "./SecretComments.module.css";
import QuestionForm from "./QuestionForm";
import QuestionsList from "./QuestionsList";
import { createQuestion, updateQuestion, deleteQuestion, Question } from "./mutations";
import {
  CREATE_USEDITEM_QUESTION_ANSWER,
  UPDATE_USEDITEM_QUESTION_ANSWER,
  DELETE_USEDITEM_QUESTION_ANSWER,
} from "./mutations";
import { Answer } from "./types";

interface SecretCommentsProps {
  secretId: string;
  questions?: Question[];
  answers?: Record<string, Answer[]>; // questionId를 키로 하는 답변 목록
}

export default function SecretComments({ 
  secretId, 
  questions = [],
  answers = {},
}: SecretCommentsProps) {
  const [localQuestions, setLocalQuestions] = useState<Question[]>(questions);
  const [localAnswers, setLocalAnswers] = useState<Record<string, Answer[]>>(answers);
  const [showForm, setShowForm] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [createAnswer] = useMutation(CREATE_USEDITEM_QUESTION_ANSWER);
  const [updateAnswer] = useMutation(UPDATE_USEDITEM_QUESTION_ANSWER);
  const [deleteAnswer] = useMutation(DELETE_USEDITEM_QUESTION_ANSWER);

  useEffect(() => {
    setLocalQuestions(questions);
  }, [questions]);

  useEffect(() => {
    setLocalAnswers(answers);
  }, [answers]);

  const handleAnswerSubmit = async (questionId: string, contents: string) => {
    setError(null);
    try {
      const { data } = await createAnswer({
        variables: {
          createUseditemQuestionAnswerInput: { contents },
          useditemQuestionId: questionId,
        },
      });

      if (data?.createUseditemQuestionAnswer) {
        const newAnswer: Answer = data.createUseditemQuestionAnswer;
        setLocalAnswers((prev) => ({
          ...prev,
          [questionId]: [...(prev[questionId] || []), newAnswer],
        }));
      }
    } catch (error: any) {
      setError(error.message || "답변 등록에 실패했습니다.");
      throw error;
    }
  };

  const handleAnswerEdit = async (answerId: string, newContents: string) => {
    setError(null);
    try {
      const { data } = await updateAnswer({
        variables: {
          updateUseditemQuestionAnswerInput: { contents: newContents },
          useditemQuestionAnswerId: answerId,
        },
      });

      if (data?.updateUseditemQuestionAnswer) {
        const updatedAnswer: Answer = data.updateUseditemQuestionAnswer;
        // 해당 답변이 속한 questionId 찾기
        const questionId = Object.keys(localAnswers).find((qId) =>
          localAnswers[qId].some((a) => a._id === answerId)
        );

        if (questionId) {
          setLocalAnswers((prev) => ({
            ...prev,
            [questionId]: prev[questionId].map((a) =>
              a._id === answerId ? updatedAnswer : a
            ),
          }));
        }
      }
    } catch (error: any) {
      setError(error.message || "답변 수정에 실패했습니다.");
      throw error;
    }
  };

  const handleAnswerDelete = async (answerId: string) => {
    setError(null);
    try {
      await deleteAnswer({
        variables: { useditemQuestionAnswerId: answerId },
      });

      // 해당 답변이 속한 questionId 찾기
      const questionId = Object.keys(localAnswers).find((qId) =>
        localAnswers[qId].some((a) => a._id === answerId)
      );

      if (questionId) {
        setLocalAnswers((prev) => ({
          ...prev,
          [questionId]: prev[questionId].filter((a) => a._id !== answerId),
        }));
      }
    } catch (error: any) {
      setError(error.message || "답변 삭제에 실패했습니다.");
      throw error;
    }
  };

  // 기존 문의하기 핸들러들...

  return (
    <section className={styles.comments} data-testid="secret-comments">
      <h3 className={styles.title}>문의하기 · 댓글</h3>
      <QuestionsList 
        questions={sortedQuestions}
        answers={localAnswers}
        onEdit={handleQuestionEdit}
        onDelete={handleQuestionDelete}
        onAnswerSubmit={handleAnswerSubmit}
        onAnswerEdit={handleAnswerEdit}
        onAnswerDelete={handleAnswerDelete}
      />
      {/* 나머지 코드... */}
    </section>
  );
}
```

### 8. CSS 스타일 가이드

#### 8.1 답변 목록 스타일
- 답변 항목은 문의 항목보다 들여쓰기된 형태로 표시
- 답변 항목 배경색: `rgba(199, 167, 74, 0.03)` (문의보다 더 어둡게)
- 답변 항목 테두리: `rgba(199, 167, 74, 0.1)` (문의보다 더 약하게)
- 답변 항목 간 간격: 8px
- 답변 항목 좌측 여백: 24px ~ 32px

#### 8.2 답변하기 버튼 스타일
- 문의 항목 내부 하단에 배치
- 기존 문의하기 버튼과 유사한 스타일
- 크기는 문의하기 버튼보다 작게 (폰트 크기: 0.875rem)
- 배경색: `rgba(199, 167, 74, 0.05)`
- 호버 시: `rgba(199, 167, 74, 0.1)`

#### 8.3 답변 작성 폼 스타일
- QuestionForm과 유사한 스타일 적용
- textarea 스타일은 QuestionForm의 textarea와 동일
- 버튼 스타일도 QuestionForm과 일관성 유지

#### 8.4 디자인 일관성
- 기존 문의하기 스타일과 일관성 유지
- 골드 색상 테마 (#c7a74a) 활용
- 다크 모드 배경 (rgba(27, 27, 27, 0.8)) 활용
- 아이콘 스타일은 기존 문의하기와 동일

### 9. 주의사항

#### 9.1 GraphQL 쿼리 수정
- 문의 조회 시 답변 목록도 함께 조회하도록 쿼리 수정 필요
- `useditemQuestion.answers` 필드를 포함하여 조회
- 답변이 없는 경우 빈 배열 처리

#### 9.2 캐시 관리
- Apollo Client 캐시 업데이트 고려
- mutation 실행 후 관련 쿼리 refetch 또는 캐시 직접 업데이트
- 낙관적 업데이트(Optimistic Update) 고려 가능

#### 9.3 에러 처리
- 답변 작성/수정/삭제 실패 시 사용자에게 에러 메시지 표시
- 네트워크 오류 등 예외 상황 처리
- 수정 모드에서 에러 발생 시 수정 모드 유지 또는 취소 처리

#### 9.4 UX 고려사항
- 답변 작성 중인 문의는 다른 답변 작성 폼 숨김 처리
- 수정 모드에서는 다른 답변 항목의 수정/삭제 비활성화
- 삭제 전 확인 다이얼로그로 실수 방지
- 로딩 상태 표시 (등록 중, 수정 중, 삭제 중 등)
- 답변 작성/수정/삭제 성공 시 피드백 제공 (선택사항)

#### 9.5 사용자 인증
- 답변 작성/수정/삭제는 로그인한 사용자만 가능할 수 있음
- 작성자만 자신의 답변을 수정/삭제할 수 있도록 권한 체크 필요 (백엔드에서 처리)

#### 9.6 데이터 동기화
- 답변 작성/수정/삭제 후 페이지 새로고침 없이 목록에 반영
- React 상태 관리 활용 (useState)
- 여러 사용자가 동시에 답변을 작성하는 경우 실시간 동기화 고려 (선택사항)

### 10. 구현 체크리스트

- [ ] GraphQL mutations 정의 (답변 작성/수정/삭제)
- [ ] GraphQL queries 수정 (답변 목록 포함)
- [ ] AnswerForm 컴포넌트 생성
- [ ] AnswerForm.module.css 생성
- [ ] QuestionsList.tsx에 답변 목록 표시 기능 추가
- [ ] QuestionsList.tsx에 답변 작성 폼 표시 기능 추가
- [ ] QuestionsList.tsx에 답변 수정/삭제 기능 추가
- [ ] QuestionsList.module.css에 답변 관련 스타일 추가
- [ ] SecretComments.tsx에 답변 관련 핸들러 추가
- [ ] SecretComments.tsx에서 QuestionsList에 답변 핸들러 전달
- [ ] 답변 작성/수정/삭제 아이콘 추가 (기존 아이콘 재사용)
- [ ] 삭제 확인 다이얼로그 구현
- [ ] 에러 처리 및 사용자 피드백
- [ ] 로딩 상태 표시
- [ ] 접근성 개선 (aria-label 등)
- [ ] 답변이 없는 경우 안내 메시지 표시
- [ ] 답변 목록 정렬 (최신순 또는 생성순)

### 11. 참고 파일

- `components/secrets-detail/SecretComments.tsx` - 메인 컴포넌트
- `components/secrets-detail/QuestionsList.tsx` - 문의 목록 컴포넌트
- `components/secrets-detail/QuestionsList.module.css` - 문의 목록 스타일
- `components/secrets-detail/QuestionForm.tsx` - 문의 작성 폼 컴포넌트
- `components/secrets-detail/QuestionForm.module.css` - 문의 작성 폼 스타일
- `components/secrets-detail/mutations.ts` - 데이터 변경 함수
- `components/secrets-detail/prompts/prompt.108.questions-feature.txt` - 문의하기 기능 구현 가이드
- `components/secrets-detail/prompts/prompt.109.questions-edit-delete-feature.txt` - 문의하기 수정/삭제 기능 구현 가이드
- `/public/images/edit.png` - 수정 아이콘
- `/public/images/delete2.png` - 삭제 아이콘

